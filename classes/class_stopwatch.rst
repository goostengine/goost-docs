:github_url: hide

.. Generated automatically by doc/tools/make_rst.py in Godot's source tree.
.. DO NOT EDIT THIS FILE, but the Stopwatch.xml source instead.
.. The source is found in doc/classes or modules/<name>/doc_classes.

.. _class_Stopwatch:

Stopwatch
=========

**Inherits:** :ref:`Node<class_Node>` **<** :ref:`Object<class_Object>`

A stopwatch to measure time intervals.

Description
-----------

A stopwatch allows to measure time intervals. It can measure elapsed time for one interval, or the total of elapsed time across multiple time intervals. To start measuring a time interval, call :ref:`start<class_Stopwatch_method_start>`, then eventually call :ref:`stop<class_Stopwatch_method_stop>`, and then check :ref:`time_elapsed<class_Stopwatch_property_time_elapsed>`.

::

    extends Node
    
    func _ready():
        var stopwatch = Stopwatch.new()
        add_child(stopwatch)
        stopwatch.start()
        yield(get_tree().create_timer(1))
        stopwatch.stop()
        print(stopwatch.time_elapsed) # Prints 1.0

Measurement can be resumed with successive :ref:`start<class_Stopwatch_method_start>` calls. Each call to :ref:`stop<class_Stopwatch_method_stop>` ends the current interval measurement and freezes the cumulative elapsed time value, which also emits the :ref:`interval_measured<class_Stopwatch_signal_interval_measured>` signal. Use method :ref:`reset<class_Stopwatch_method_reset>` to clear the elapsed time to zero in order to measure new time intervals.

Since the class is used to measure time intervals between existing events of interest, the stopwatch does not have a notion of maximum elapsed time, nor has a timeout signal. Use :ref:`Timer<class_Timer>` node for this purpose instead.

Properties
----------

+------------------------------------------------+------------------------------------------------------------+-----------+
| :ref:`bool<class_bool>`                        | :ref:`autostart<class_Stopwatch_property_autostart>`       | ``false`` |
+------------------------------------------------+------------------------------------------------------------+-----------+
| :ref:`ProcessMode<enum_Stopwatch_ProcessMode>` | :ref:`process_mode<class_Stopwatch_property_process_mode>` | ``1``     |
+------------------------------------------------+------------------------------------------------------------+-----------+
| :ref:`float<class_float>`                      | :ref:`time_elapsed<class_Stopwatch_property_time_elapsed>` |           |
+------------------------------------------------+------------------------------------------------------------+-----------+

Methods
-------

+-------------------------+--------------------------------------------------------------------------+
| :ref:`bool<class_bool>` | :ref:`is_running<class_Stopwatch_method_is_running>` **(** **)** |const| |
+-------------------------+--------------------------------------------------------------------------+
| :ref:`bool<class_bool>` | :ref:`is_stopped<class_Stopwatch_method_is_stopped>` **(** **)** |const| |
+-------------------------+--------------------------------------------------------------------------+
| void                    | :ref:`reset<class_Stopwatch_method_reset>` **(** **)**                   |
+-------------------------+--------------------------------------------------------------------------+
| void                    | :ref:`start<class_Stopwatch_method_start>` **(** **)**                   |
+-------------------------+--------------------------------------------------------------------------+
| void                    | :ref:`stop<class_Stopwatch_method_stop>` **(** **)**                     |
+-------------------------+--------------------------------------------------------------------------+

Signals
-------

.. _class_Stopwatch_signal_interval_measured:

- **interval_measured** **(** :ref:`float<class_float>` time_interval, :ref:`float<class_float>` time_start, :ref:`float<class_float>` time_stop **)**

Emitted when the stopwatch stops the measurement of a time interval. The ``time_interval`` is the difference between elapsed times between :ref:`start<class_Stopwatch_method_start>` and :ref:`stop<class_Stopwatch_method_stop>` calls. The signal also provides the start and stop times via ``time_start`` and ``time_stop`` respectively.

If the stopwatch is started and then immediately stopped, the signal is not emitted.

Enumerations
------------

.. _enum_Stopwatch_ProcessMode:

.. _class_Stopwatch_constant_PROCESS_PHYSICS:

.. _class_Stopwatch_constant_PROCESS_IDLE:

enum **ProcessMode**:

- **PROCESS_PHYSICS** = **0** --- Update the stopwatch during the physics step at each frame (fixed framerate processing).

- **PROCESS_IDLE** = **1** --- Update the stopwatch during the idle time at each frame.

Property Descriptions
---------------------

.. _class_Stopwatch_property_autostart:

- :ref:`bool<class_bool>` **autostart**

+-----------+----------------------+
| *Default* | ``false``            |
+-----------+----------------------+
| *Setter*  | set_autostart(value) |
+-----------+----------------------+
| *Getter*  | has_autostart()      |
+-----------+----------------------+

If ``true``, the stopwatch will automatically start when entering the :ref:`SceneTree<class_SceneTree>`.

\ **Note:** This property is automatically set to ``false`` after the stopwatch enters the :ref:`SceneTree<class_SceneTree>` and starts.

----

.. _class_Stopwatch_property_process_mode:

- :ref:`ProcessMode<enum_Stopwatch_ProcessMode>` **process_mode**

+-----------+-------------------------+
| *Default* | ``1``                   |
+-----------+-------------------------+
| *Setter*  | set_process_mode(value) |
+-----------+-------------------------+
| *Getter*  | get_process_mode()      |
+-----------+-------------------------+

Processing mode. See :ref:`ProcessMode<enum_Stopwatch_ProcessMode>`.

----

.. _class_Stopwatch_property_time_elapsed:

- :ref:`float<class_float>` **time_elapsed**

+----------+--------------------+
| *Getter* | get_time_elapsed() |
+----------+--------------------+

The cumulative measured time interval. Returns ``0.0`` if the stopwatch has not been started yet with :ref:`start<class_Stopwatch_method_start>` or reset to zero with :ref:`reset<class_Stopwatch_method_reset>`.

Method Descriptions
-------------------

.. _class_Stopwatch_method_is_running:

- :ref:`bool<class_bool>` **is_running** **(** **)** |const|

Returns ``true`` if the stopwatch is in the process of measuring a time interval. The opposite of :ref:`is_stopped<class_Stopwatch_method_is_stopped>`.

----

.. _class_Stopwatch_method_is_stopped:

- :ref:`bool<class_bool>` **is_stopped** **(** **)** |const|

Returns ``true`` if the stopwatch is inactive (or hasn't been started yet). The opposite of :ref:`is_running<class_Stopwatch_method_is_running>`.

----

.. _class_Stopwatch_method_reset:

- void **reset** **(** **)**

Stops time interval measurement and resets the :ref:`time_elapsed<class_Stopwatch_property_time_elapsed>` to zero. The stopwatch cannot be reset if it's already running. In that case, call :ref:`stop<class_Stopwatch_method_stop>` before resetting the stopwatch.

----

.. _class_Stopwatch_method_start:

- void **start** **(** **)**

Starts (or resumes) measuring elapsed time for an interval.

----

.. _class_Stopwatch_method_stop:

- void **stop** **(** **)**

Stops measuring elapsed time for an interval. Emits the :ref:`interval_measured<class_Stopwatch_signal_interval_measured>`. You can reset the stopwatch to zero by calling :ref:`reset<class_Stopwatch_method_reset>` manually.

.. |virtual| replace:: :abbr:`virtual (This method should typically be overridden by the user to have any effect.)`
.. |const| replace:: :abbr:`const (This method has no side effects. It doesn't modify any of the instance's member variables.)`
.. |vararg| replace:: :abbr:`vararg (This method accepts any number of arguments after the ones described here.)`
